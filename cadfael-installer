#!/bin/bash
# VERY dumb installer for CadfaelBrew - in Bash for maximum portability
# at present. Maybe Python/Ruby later on if more advanced functionality
# is needed.
# - Determine system
# - Check deps
# - Bootstrap Ruby if needed
# - Checkout correct repo
# - brew doctor
# - brew install [ruby] cadfael
# - brew install bayeux
# - brew install falaise
#
# - Currently supported systems:
#   RHEL family 5/6/7
#   SUSE Enterprise 11
#   Ubuntu 14.04 LTS
#   Mac OSX 10.9-11
#
# - How to add support for new Linux systems
#   1) Get the output of `lsb_release -si | sed 's/ //g'`
#      This is used to set the global variable 'kOSDISTRO'
#      Get the output of `lsb_release -sr`
#      This is used to set the global variable 'kOSVERSION`
#   2) Add a regex to to the global array 'kSUPPORTEDSYSTEMS` that
#      will match the string 'kOSDISTRO-kOSVERSION' as derived for
#      your system above
#   3) Add a function named 'doCheck-DIST-VERSION', replacing DIST and
#      VERSION in this name with the values derived in step 1)
#   4) In this function, implement checks for required system packages
#      using the system package manager. If your system uses deb or
#      rpm packages, you can use the checkRPM and checkDeb helper
#      functions (See 'doCheckRedHat-6` and `doCheckUbuntu-14.04`
#      for example usage). The function *must* return 0 if all
#      checks are passed, or 1 otherwise. You should implement the checks
#      such that all are performed and the names of any missing packages
#      collated. This list should be reported using the '_echo_error`
#      logging function, and inform the user on the steps needed to
#      install them (e.g. "you need to run 'pkger install foo bar'")
#   5) Brew requires that the GNU compilers, whether on the system
#      or brewed, are named '<program>-<major>.<minor>', e.g. 'gcc-4.9'.
#      This script creates links to the system compiler in this format
#      automatically in the function 'doCreateCompilerLinks'. If your 
#      system names gcc programs using a custom name or you wish to use
#      a specific version, then you may add additional logic in this 
#      function to link to the required GCC. For example, on RedHat5
#      we need to use the system install of gcc 4.4, but on this system
#      the executables are named 'gcc44' and 'g++44'.

#-----------------------------------------------------------------------
# MINIMAL API
#-----------------------------------------------------------------------
# - Logging
#
# - Exit with failure
_echo_exit()
{
  _echo_error "$1"
  exit 1
}

# - Info
_echo_info()
{
  echo "[cadfael:info] $1"
}

# - Warning
_echo_warning()
{
  echo "[cadfael:warning] $1" 1>&2
}

# - Error
_echo_error()
{
  echo "[cadfael:error] $1" 1>&2
}

#-----------------------------------------------------------------------
# GLOBAL VALUES/SETTINGS
#-----------------------------------------------------------------------
# - Self location and CWD
readonly kCADFAELINSTALLERDIR=`dirname "$0"`
readonly kWORKINGDIR=`pwd`

# - Github baseurl
readonly kGITHUBORG="SuperNEMO-DBD"
readonly kGITHUBURL="https://github.com/$kGITHUBORG"
readonly kCADFAELTAP="$kGITHUBORG/cadfael"

# - Supported systems
# Use regexs to simplify distro family support. Split out into distinct
# members when needed.
readonly _kRHELIDREGEX='(RedHatEnterprise[[:alpha:]]*|CentOS|Scientific[[:alpha:]]*)'

declare -a kSUPPORTEDSYSTEMS
readonly kSUPPORTEDSYSTEMS=("MacOSX-10\.(8|9|10|11)" \
                            "${_kRHELIDREGEX}-[5-7]\.[0-9][0-9]?" \
                            "SUSELINUX-11" \
                            "Ubuntu-14\.04")

# - Operating System ID, Version and Packaging System
doInit() {
  readonly kOS=$(uname -s)

  case "$kOS" in
    "Darwin")
      readonly kOSDISTRO=$(sw_vers -productName | sed 's/ //g')
      readonly kOSVERSION=$(sw_vers -productVersion | cut -d. -f1,2)
      readonly kPACKAGETOOL="pkg"
      ;;
    "Linux")
      # - Determine distro
      kLSB_RELEASE=$(command -v lsb_release)
      if [ -n "${kLSB_RELEASE}" ] ; then
        readonly kOSDISTRO=$($kLSB_RELEASE -si | sed 's/ //g')
        readonly kOSVERSION=$($kLSB_RELEASE -sr)
      else
        # Long term, probably want to check existence of the
        # /etc/<NAME>-release files because lsb_release may not always
        # be installed on a base system
        _echo_exit "error: No 'lsb_release' command found"
      fi

      # - Determine package/manager system
      case "$kOSDISTRO" in 
        Debian|Ubuntu)
          readonly kPACKAGETOOL="dpkg"
          readonly kPACKAGEMANAGER="apt-get"
          ;;
        RedHat.*|CentOS|Scientific.*)
          readonly kPACKAGETOOL="rpm"
          readonly kPACKAGEMANAGER="yum"
          ;;
        SUSELINUX)
          readonly kPACKAGETOOL="rpm"
          readonly kPACKAGEMANAGER="zypper"
          ;;
        *)
          # Can only mark as empty and warn later on that no packages can
          # be checked
          readonly kPACKAGETOOL="<unknown:packagetool>"
          readonly kPACKAGEMANAGER="<unknown:packagemanager>"
          ;;
      esac
      ;;
    *)
      # A hard fail here because we really can't progress any further
      _echo_error "Unsupported OS '$kOS'"
      _echo_exit  "Only Linux and Darwin are currently supported"
      ;;
  esac

  # - Architecture
  readonly kARCH=$(uname -m)
  if [ "${kARCH}" != "x86_64" ] ; then
    # Hard fail because it's not worth going any further
    _echo_error "Unsupported architecture '$kARCH'"
    _echo_exit  "Only 'x86_64' architectures are currently supported"
  fi
}

#-----------------------------------------------------------------------
# MAIN API
#-----------------------------------------------------------------------
# - System validation
# Take system 'distro-version' string and return 0 if supported, 1 otherwise
isSystemSupported () {
  local elem
  for elem in "${kSUPPORTEDSYSTEMS[@]}" ; do
    [[ "$1" =~ $elem ]] && return 0
  done
  return 1
}

#-----------------------------------------------------------------------
# Redhat/CentOS/Scientifc form a family of distros, so we treat these
# as a single distro for now, only distinguished by major version number
# - Return true if OS is RedHat Family
isRedHatFamily () {
  [[ "$kOSDISTRO" =~ $_kRHELIDREGEX ]] && return 0
  return 1
}

# Get the RedHat major version
getRedHatMajorVersion () {
  if isRedHatFamily ; then
    echo "$(echo $kOSVERSION | cut -d. -f1)"
    return 0
  fi
  echo "NOTREDHAT"
  return 1
}

#-----------------------------------------------------------------------
# - Absolute-ize supplied path, which may not exist
#   On Linux, just use GNU readlink, on Mac, use Python
#   This is messy, but BSD readlink doesn't support '-m'
#   TODO: is there a pure Bash/POSIX way to do this?
getAbsolutePath() {
  case "$kOS" in
    "Linux")
      echo $(readlink -m "$1")
      ;;
    "Darwin")
      echo $(python -c "import os,sys;print(os.path.realpath(sys.argv[1]))" "$1")
      ;;
    *)
      _echo_exit "getAbsolutePath called on unsupported '$kOS'"
      ;;
  esac
}

#-----------------------------------------------------------------------
# - Report info on OS, distro, version
#   Can be run on any system, but mainly intended to supply info
#   on new systems to help in starting support
#   Sort of redundant given checks done on startup, but can help
#   to give some info upstream.
doReportSystemInfo() {
  # uname info
  unameArch=$(uname -m)
  unameOSName=$(uname -s)
  unameOSRelease=$(uname -r)
  unameOSVersion=$(uname -v)

  printf -v jsonUnameInfo '"uname": {"arch": "%s", "name":"%s". "release":"%s", "version": "%s"}' \
    "$unameArch" \
    "$unameOSName" \
    "$unameOSRelease" \
    "$unameOSVersion"


  # OS info
  case "$unameOSName" in
    "Darwin")
      printf -v jsonOsInfo '"Darwin": { "productName": "%s", "productVersion": "%s", "buildVersion": "%s"}' \
        "$(sw_vers -productName)" \
        "$(sw_vers -productVersion)" \
        "$(sw_vers -buildVersion)"
      ;;
    "Linux")
      linuxReleaseFiles=""
      for f in $(ls /etc/*-release) ; do
        fileContent="$(cat $f)"
        if [ -z "$linuxReleaseFiles" ] ; then
          linuxReleaseFiles="{\"file\": \"$f\", \"content\": \"$fileContent\"}"
        else
          linuxReleaseFiles="$linuxReleaseFiles, {\"file\": \"$f\", \"content\": \"$fileContent\"}"
        fi
      done
      
      printf -v jsonOsInfo '"Linux": { "releaseFiles": [%s]}' \
        "$linuxReleaseFiles"
      ;;
    *)
      osInfo="tobedetermined"
      ;;
  esac

  # JSON-ize
  printf '{%s, %s}\n' "$jsonUnameInfo" "$jsonOsInfo"
}

#-----------------------------------------------------------------------
# LINUX PACKAGE CHECKS
# - Each supported system will have list of package names to be checked
# possibly also package groups. That should then be input to relevant
# package query check. Any missing packages should be collected and
# reported to user in a command line format, e.g.
#
# """
# Your system has missing packages, please run
#
#   yum install foo bar baz
#"""

#-----------------------------------------------------------------------
# Check if a given rpm package is installed
# Echo package name-version-release string if installed, "no" otherwise
checkRPM () {
  isInstalled=$(rpm -q $1 --qf "%{NAME}-%{VERSION}-%{RELEASE}")
  if [ $? -eq 0 ] ; then
    _echo_info "Checking for install of rpm '$1': $isInstalled"
    return 0
  else
    _echo_error "RPM '$1' is not installed"
    return 1
  fi
}

#-----------------------------------------------------------------------
# Check if a given deb package is installed
checkDeb () {
  isInstalled=$(dpkg-query -W -f='${Version} ${Status}' "$1")
    if [ $? -eq 0 ] ; then
    _echo_info "Checking for install of deb '$1': $isInstalled"
    return 0
  else
    _echo_error "deb '$1' is not installed"
    return 1
  fi

}

#-----------------------------------------------------------------------
# General Checks for RHEL based systems
# - RHEL 5.X
doCheckRedHat-5 () {
  _echo_info "Checking system software for RedHat5 ($kOSDISTRO)"
  local rpmList=("expat-devel" \
                 "gcc44" \
                 "gcc44-c++" \
                 "gcc44-gfortran" \
                 "git" \
                 "glibc-devel" \
                 "HEP_OSlibs_SL5" \
                 "ruby-irb" \
                 "redhat-lsb" \
                 "mesa-libGL-devel" \
                 "mesa-libGLU-devel" \
                 "ncurses-devel" \
                 "libX11-devel" \
                 "libXau-devel" \
                 "libXdamage-devel" \
                 "libXdmcp-devel" \
                 "libXext-devel" \
                 "libXfixes-devel" \
                 "libXft-devel" \
                 "libXpm-devel")
  for pkg in "${rpmList[@]}"  ; do
    if ! checkRPM $pkg ; then
      local missingPkgs="$pkg ${missingPkgs}"
    fi
  done

  # Yum groups
  local devGroup="Development tools"
  local devGroupSansSpace=$(echo $devGroup | tr -d '[:space:]')


  if yum grouplist "$devGroup" 2>/dev/null | tr -d '[:space:]' | grep -i "InstalledGroups:$devGroupSansSpace" > /dev/null ; then
    _echo_info "Checking for install of Yum Group '$devGroup': Installed"
  else
    _echo_error "Yum Group '$devGroup' is not installed"
    local missingGroups="'$devGroup'"
  fi

  local returnVal=0

  if [ -n "$missingPkgs" ] ; then
    _echo_error "RPMs '$missingPkgs' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  $kPACKAGEMANAGER install $missingPkgs

  "
    returnVal=1
  fi

  if [ -n "$missingGroups" ] ; then
    _echo_error "Yum Groups '$missingGroups' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  yum groupinstall $missingGroups

  "
    returnVal=1
  fi

  return $returnVal
}

# - RHEL 6.X
doCheckRedHat-6 () {
  _echo_info "Checking system software for RedHat6 ($kOSDISTRO)"

  local rpmList=("expat-devel" \
                 "git.x86_64" \
                 "openssl-devel" \
                 "ruby-irb.x86_64" \
                 "HEP_OSlibs_SL6")

  for pkg in "${rpmList[@]}"  ; do
    if ! checkRPM $pkg ; then
      local missingPkgs="$pkg ${missingPkgs}"
    fi
  done

  # Yum groups
  local devGroup="Development tools"
  local devGroupSansSpace=$(echo $devGroup | tr -d '[:space:]')


  if yum grouplist "$devGroup" 2>/dev/null | tr -d '[:space:]' | grep -i "InstalledGroups:$devGroupSansSpace" > /dev/null ; then
    _echo_info "Checking for install of Yum Group '$devGroup': Installed"
  else
    _echo_error "Yum Group '$devGroup' is not installed"
    local missingGroups="'$devGroup'"
  fi

  local returnVal=0

  if [ -n "$missingPkgs" ] ; then
    _echo_error "RPMs '$missingPkgs' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  $kPACKAGEMANAGER install $missingPkgs

  "
    returnVal=1
  fi

  if [ -n "$missingGroups" ] ; then
    _echo_error "Yum Groups '$missingGroups' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  yum groupinstall $missingGroups

  "
    returnVal=1
  fi

  return $returnVal
}

# - RHEL 7.X
doCheckRedHat-7 () {
  _echo_info "Checking system software for RedHat7 ($kOSDISTRO)"

  local rpmList=("expat-devel" \
                 "git" \
                 "openssl-devel" \
                 "redhat-lsb-core" \
                 "ruby-irb" \
                 "glibc-static" \
                 "libstdc++-static" \
                 "HEP_OSlibs")

  for pkg in "${rpmList[@]}"  ; do
    if ! checkRPM $pkg ; then
      local missingPkgs="$pkg ${missingPkgs}"
    fi
  done

  # Yum groups
  local devGroup="Development tools"
  local devGroupSansSpace=$(echo $devGroup | tr -d '[:space:]')

  if yum grouplist "$devGroup" 2>/dev/null | tr -d '[:space:]' | grep -i "InstalledGroups:$devGroupSansSpace" > /dev/null ; then
    _echo_info "Checking for install of Yum Group '$devGroup': Installed"
  else
    _echo_error "Yum Group '$devGroup' is not installed"
    local missingGroups="'$devGroup'"
  fi

  local returnVal=0

  if [ -n "$missingPkgs" ] ; then
    _echo_error "RPMs '$missingPkgs' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  $kPACKAGEMANAGER install $missingPkgs

  "
    returnVal=1
  fi

  if [ -n "$missingGroups" ] ; then
    _echo_error "Yum Groups '$missingGroups' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  yum groupinstall $missingGroups

  "
    returnVal=1
  fi

  return $returnVal
}

#-----------------------------------------------------------------------
# SUSELINUX-11 check
doCheckSUSELINUX-11 () {
  _echo_info "Checking system software for 'SUSELINUX-11'"

  local rpmList=("curl" \
                 "git" \
                 "m4" \
                 "ruby" \
                 "texinfo" \
                 "libbz2-devel" \
                 "libcurl-devel" \
                 "libexpat-devel" \
                 "ncurses-devel" \
                 "zlib-devel")

  for pkg in "${rpmList[@]}"  ; do
    if ! checkRPM $pkg ; then
      local missingPkgs="$pkg ${missingPkgs}"
    fi
  done

  if [ -n "$missingPkgs" ] ; then
    _echo_error "RPMs '$missingPkgs' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  $kPACKAGEMANAGER install $missingPkgs
  "
    return 1
  fi

  return 0
}


#-----------------------------------------------------------------------
# Ubuntu Checks
#-----------------------------------------------------------------------
# 14.04 (Trusty LTS)
doCheckUbuntu-14.04 () {
  _echo_info "Checking system software for Ubuntu 14.04"

  local debList=("build-essential" \
                 "curl" \
                 "git" \
                 "m4" \
                 "libbz2-dev" \
                 "libcurl4-openssl-dev" \
                 "libexpat-dev" \
                 "libncurses-dev" \
                 "ruby2.0" \
                 "texinfo" \
                 "zlib1g-dev" \
                 "libx11-dev" \
                 "libxpm-dev" \
                 "libxft-dev" \
                 "libxext-dev" \
                 "libpng12-dev" \
                 "libjpeg-dev")

  for pkg in "${debList[@]}"  ; do
    if ! checkDeb $pkg ; then
      local missingPkgs="$pkg ${missingPkgs}"
    fi
  done

  if [ -n "$missingPkgs" ] ; then
    _echo_error "Debs '$missingPkgs' are not installed on this system"
    _echo_error "Please run (or get your sysadmin to run):

  $kPACKAGEMANAGER install -y $missingPkgs
  "
    return 1
  fi

  return 0
}

#-----------------------------------------------------------------------
# DARWIN CHECKS
#-----------------------------------------------------------------------
# - OS X 10.11/El Capitan
doCheckMacOSX-10.11 () {
  developerDir=$(/usr/bin/xcode-select -print-path 2>/dev/null)
  if [ -z "$developerDir" ] || [ ! -f "$developerDir/usr/bin/git" ] ; then
    _echo_info "Installing the Command Line Tools (expect a GUI popup):"
    sudo /usr/bin/xcode-select --install || _echo_exit "Failed to install Command Line Tools"
  fi
  return 0
}

# - OS X 10.10/Yosemite
doCheckMacOSX-10.10 () {
  doCheckMacOSX-10.11
  return $?
}

# - OS X 10.9/Mavericks
doCheckMacOSX-10.9 () {
  doCheckMacOSX-10.10
  return $?
}

# OS X 10.8/Mountain Lion
doCheckMacOSX-10.8 () {
  doCheckMacOSX-10.10
  return $?
}

#-----------------------------------------------------------------------
# CADFAEL BREW SETUP
#-----------------------------------------------------------------------
# - Does the system supply a suitable Ruby version?
isSystemRubySuitable () {
  local minRequiredMajor="1"
  local minRequiredMinor="9"

  local systemRubyVersion=$(ruby --version | cut -d" " -f2)
  local systemRubyVersionMajor=$(echo $systemRubyVersion | cut -d. -f1)
  local systemRubyVersionMinor=$(echo $systemRubyVersion | cut -d. -f2)

  _echo_info "System ruby (`type -P ruby`) version : $systemRubyVersionMajor.$systemRubyVersionMinor"

  [[ "$systemRubyVersionMajor" -gt "$minRequiredMajor" ]] && return 0
  [[ "$systemRubyVersionMajor" -eq "$minRequiredMajor" ]] && \
    [[ "$systemRubyVersionMinor" -ge "$minRequiredMinor" ]] && return 0

  return 1;
}

# - Bootstrap a temporary Ruby install to update brew, then brew install
# ruby
# - Temporarily use postmodern's ruby-install 
doBootstrapRuby () {
  local rubyBSDir="$1"
  local rubySrcDir="$rubyBSDir/src"
  git clone https://github.com/postmodern/ruby-install.git "$rubyBSDir"
  "$rubyBSDir"/bin/ruby-install \
    -j4 \
    -i "$rubyBSDir" \
    -s "$rubySrcDir" \
    --no-install-deps \
    ruby 2.0 -- \
    --disable-install-doc || return 1
  return 0
}


#-----------------------------------------------------------------------
# Get system software checking function for supplied system
getSystemCheckFunction () {
  if isRedHatFamily ; then
    local majorVersion=$(getRedHatMajorVersion)
    echo "doCheckRedHat-$majorVersion"
    return 0
  else
    echo "doCheck$1"
    return 0
  fi

  _echo_error "No valid checking function for '$1'"
  return 1
}

#-----------------------------------------------------------------------
# - Check that the OS provides the software on which brew relies
#   On OSX, homebrew's doctor will handle this for us, though note
#   that their installer also checks for Xcode
#   On Linux, defer to more involved checking system
doCheckSystemSoftware () {
  _echo_info "in doCheckSystemSoftware $kOSDISTRO-$kOSVERSION"
  if isSystemSupported "$kOSDISTRO-$kOSVERSION" ; then
    _echo_info "System supported"
    $(getSystemCheckFunction "$kOSDISTRO-$kOSVERSION")
    return $?
  else
    _echo_warning "Unsupported distribution '$kOSDISTRO' ($kOSVERSION) on '$kOS'

  Installation will proceed without system checks or initial bootstrapping
  See further instructions at <url>
  "
    return 0
  fi
}

#-----------------------------------------------------------------------
# Clone appropriate github repo for this OS into supplied directory
doGithubClone () {
  local baseurl="$kGITHUBURL"
  local reponame=""
  case "$kOS" in
    "Darwin")
      reponame="cadfaelbrew.git"
      ;;
    "Linux")
      reponame="cadfaelbrew.git"
      ;;
    *)
      _echo_exit "doGithubClone run with unknown kOS('$kOS')"
      ;;
  esac

  local cloneurl="$baseurl/$reponame"
  local clonedir=$(getAbsolutePath "$1/Cadfael.git")

  if [ -d "$clonedir" ] ; then
    _echo_exit "Installation destination '$clonedir' exists"
  fi

  _echo_info "Cloning '$reponame' into $clonedir"
  git clone "$cloneurl" "$clonedir"
  return $?
}

#-----------------------------------------------------------------------
# Create compiler softlinks on RHEL platforms 
# brew requires GCCs to be named 'gcc-<version>'
doCreateCompilerLinks () {
  if isRedHatFamily ; then 
    _echo_info "Creating system compiler softlinks for bootstrapping"
    if [ `getRedHatMajorVersion` == "5" ] ; then
      gcc_suffix="44";
    fi

    ln -s /usr/bin/gcc${gcc_suffix} "$1/Cadfael.git/bin/gcc-$(/usr/bin/gcc${gcc_suffix} -dumpversion | cut -d. -f1,2)" || _echo_warning "Failed to create softlink to system gcc"
    ln -s /usr/bin/g++${gcc_suffix} "$1/Cadfael.git/bin/g++-$(/usr/bin/g++${gcc_suffix} -dumpversion | cut -d. -f1,2)" || _echo_warning "Failed to create softlink to system g++"
  fi
}


#-----------------------------------------------------------------------
# Perform initial setup of Brew
# Tap Cadfael, run doctor
doBrewSetup() {
  _echo_info "setting up brew"
  if [ -z "$1" ] ; then _echo_exit "No install directory" ; fi

  doCreateCompilerLinks $1

  # - Is system Ruby sufficient?
  local rubyBootstrap="$1/Cadfael.git/.rubybs"
  if ! isSystemRubySuitable ; then
    _echo_info "Bootstrapping ruby"
    doBootstrapRuby "$rubyBootstrap" || _echo_exit "Unable to bootstrap ruby"
  fi

  _echo_info "Updating cadfaelbrew"
  if ! PATH="$1/Cadfael.git/bin:$rubyBootstrap/bin:$PATH" brew update ; then
    _echo_exit "failed to update cadfaelbrew from GitHub"
  fi


  if ! PATH="$1/Cadfael.git/bin:$rubyBootstrap/bin:$PATH" brew doctor ; then
    _echo_warning "brew doctor issued warnings

  These generally are not severe on a first pass on supported platforms and
  can be ignored for now.
 
  If you're installing on an unsupported platform, please review them.
  "
  fi

  # Now ready, roughly, to brew ruby if bootstrap was done
  if [ -d "$rubyBootstrap" ] ; then
    _echo_info "Brewing ruby"
    if ! PATH="$1/Cadfael.git/bin:$rubyBootstrap/bin:$PATH" brew install ruby ; then
      _echo_exit "failed to brew ruby"
    fi

    # Remove the bootstrap
    rm -Rf "$rubyBootstrap" || _echo_warning "Failed to remove bootstrapped Ruby under '$rubyBootstrap'"
    _echo_info "Brewing of Ruby complete"
  fi

  # Report brew config/env
  _echo_info "CadfaelBrew set up with config:"
  PATH="$1/Cadfael.git/bin:$rubyBootstrap/bin:$PATH" brew config || _echo_exit "internal brew error"

  _echo_info "CadfaelBrew default build environment:"
  PATH="$1/Cadfael.git/bin:$rubyBootstrap/bin:$PATH" brew --env || _echo_exit "internal brew error"

  _echo_info "CadfaelBrew install and setup complete under '$installPrefix'"
  return 0
}


#-----------------------------------------------------------------------
# Brew a given formulae under the install prefix
#
doBrewFormula() {
  _echo_info "Starting brew of $2"
  if [ -z "$1" ] ; then _echo_exit "No install directory" ; fi
  if [ ! -x "$1/Cadfael.git/bin/brew" ] ; then
    _echo_exit "No executable 'brew' command under '$1/Cadfael.git'"
  fi

  if ! PATH="$1/Cadfael.git/bin:$PATH" brew install $2 $3; then
    _echo_warning "Failed to 'brew install $2 $3'
  
  This is likely due to a failure to build one of its dependencies:

  $(PATH="$1/Cadfael.git/bin:$PATH" brew deps -n1 $2)

  To proceed, change into the directory

  $1/Cadfael.git/bin

  and manually run

  ./brew install -v $2

  This will pick up installation at the last, and failing formula. The
  '-v' option will produce more output to help track down the error.
  This, plus listed log files can be reported as an issue to the
  appropriate issue tracker, either mailing list or to GitHub
  if you have an account there
  "
    return 1
  fi

  _echo_info "$2 Formulae brewed o.k."
  return 0
}

#-----------------------------------------------------------------------
# Actually brew cadfael, if required
#
doBrewCadfael() {
  doBrewFormula $1 cadfael $2
  return $?
}

#-----------------------------------------------------------------------
# Actually brew bayeux, if required
#
doBrewBayeux() {
  doBrewFormula $1 bayeux $2
  return $?
}

#-----------------------------------------------------------------------
# Actually brew falaise, if required
#
doBrewFalaise() {
  doBrewFormula $1 falaise $2
  return $?
}

#-----------------------------------------------------------------------
# Check basic network connectivity by pinging github...
doCheckNetwork() {
  _echo_info "Checking basic network connectivity"
  ping -c 3 github.com > /dev/null
  return $?
}

#-----------------------------------------------------------------------
# Output some help on setup
#
doHelpSetup() {
  cat <<EOF
Install of CadfaelBrew complete under

$1

To use the programs and libraries supplied by Cadfael you can:

1. (Recommended) Use brew's setup facility to start a new shell session
   with the environment correctly configured:

   $ $1/Cadfael.git/bin/brew sh

   This starts a new shell with PATH and other environment variables
   set correctly. Just exit the shell to return to your original session.

2. Set the following environment variables either directly in your
   shell's .rc file or through the configuration mechanism of your choice
   (e.g. Environment Modules)

   PATH="$1/Cadfael.git/bin:\$PATH"
   MANPATH="$1/Cadfael.git/share/man:\$MANPATH"
   INFOPATH="$1/Cadfael.git/share/info:\$INFOPATH"

In both cases that should be all that's needed, though certain use cases
may also required the dynamic loader or Python path to be set. This is
to be reviewed.
EOF
}

#-----------------------------------------------------------------------
# Usage and Help
#
displayUsage() {
  echo "Usage: cadfael-installer [-h] [-p <prefix>]"
}

displayHelp() {
  cat <<EOF
$(displayUsage)

Install Cadfael.git package manager and base SDK for SuperNEMO.
Checks if OS is supported, checks that required system software is present,
clones git repository.

Requires a working network connection.

Arguments:
  -h                    Print this help message and exit
  -s                    Print information on system, whether supported
                        or not and exit
  -p [DIR]              Install Cadfael.git bundle under DIR
                        If DIR is not provided, it defaults to the
                        current working directory
  -b                    Do not install Cadfael Formula after bootstrapping
                        CadfaelBrew
  -e                    Install all formulae with C++11 support 

Exit status:
  0  if OK
  1  if any step failed

Messages are logged to stdout/stderr as required.

EOF
}

#-----------------------------------------------------------------------
# IMPLEMENTATION

main() {
  local installPrefix=$(pwd)

  while getopts ":hsbep:" opt ; do
    case $opt in
      e)
        local cppStdOption="--c++11"
        ;;
      b)
        local bareInstall="bareInstall"
        ;;
      p)
        local installPrefix="$OPTARG"
        ;;
      s)
        doReportSystemInfo
        return 0
        ;;
      h)
        displayHelp
        return 0
        ;;
      \?)
        displayUsage
        _echo_exit "Invalid option '-$OPTARG'"
        ;;
      :)
        displayUsage
        _echo_exit "Option '-$OPTARG' requires an argument"
        ;;
      *)
        _echo_exit "Internal command line parsing error"
        ;;
    esac
  done

  doInit
  _echo_info "Detected '$kOS' Operating System"
  _echo_info "Distribution '$kOSDISTRO ($kOSVERSION)'"

  doCheckSystemSoftware || _echo_exit "System software check failed"
  doCheckNetwork || _echo_exit "Cannot connect to github.com, check your netowrk connection"
  doGithubClone "$installPrefix" || _echo_exit "Clone of CadfaelBrew repo failed"
  doBrewSetup "$installPrefix" || _echo_exit "CadfaelBrew setup failed"
  if [ -z "$bareInstall" ] ; then
    doBrewCadfael "$installPrefix" $cppStdOption || _echo_exit "Brewing of Cadfael formula failed"
    doBrewBayeux "$installPrefix" $cppStdOption || _echo_exit "Brewing of Bayeux formula failed" 
    doBrewFalaise "$installPrefix" $cppStdOption || _echo_exit "Brewing of Falaise formula failed"
  fi

  doHelpSetup "$installPrefix"

  if [ -n "$bareInstall" ] ; then
    echo "
Note that you have not as yet installed the Cadfael formula, so you 
should now do:

  \$ $installPrefix/Cadfael.git/bin/brew install cadfael

optionally followed by

  \$ $installPrefix/Cadfael.git/bin/brew install falaise

  "
  fi

  return 0
}

main "$@"
exit $?
